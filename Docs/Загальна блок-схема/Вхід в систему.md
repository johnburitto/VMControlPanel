<mark style="background: #FFF3A3A6;">ToDo:</mark>
- [x] <mark style="background: #BBFABBA6;">Написання методу, який буде виконувати вхід користувача в систему ✅ 2024-03-05</mark>

## Написання методу, який буде виконувати вхід користувача в систему
Оскільки користувач може входити в систему, виходити із неї, реєструватися в системі, дані, які він надає для входу, можуть бути невірними, тому було вирішено написати енумератор AuthResponse, який буде відображати стан автентифікації в системі:
```CSharp
public enum AuthResponse
{
    SuccessesLogin,
    SuccessesRegister,
    BadCredentials,
    AlreadyRegistered
}
```

Також було створено Dto-об'єкт LoginDto, який буде нести в собі всі дані необхідні для входу в систему:
```CSharp
public class LoginDto
{
    public string? UserName { get; set; }
    public string? Password { get; set; }
}
```

Метод в інтерфейсі, який буде відповідати за вхід в систему:
```CSharp
Task<AuthResponse> LoginAsync(LoginDto dto);
```

Для більшої безпеки застосунку в базі даних зберігається не пароль, що ввів користувач, а його hash-образ, захешований за допомогою SHA256. При спробі входу ті дані, які користувач ввів як пароль, будуть захешовані та порівняні з тими, що знаходяться в базі даних та відповідають тому логіну, що був введений. Для хешування був написаний наступний приватний метод:
```CSharp
private static string ComputeSha256Hash(string? data)
{
    if (data == null)
    {
        return "";
    }
    
    var bytes = SHA256.HashData(Encoding.UTF8.GetBytes(data));
    var strBuilder = new StringBuilder();

    foreach (var _ in bytes)
    {
        strBuilder.Append(_.ToString("x2"));
    }

    return strBuilder.ToString();
}
```

Реалізація методу LoginAsync:
```CSharp
public async Task<AuthResponse> LoginAsync(LoginDto dto)
{
    var user = await _context.Users.Where(_ => _.UserName == dto.UserName && _.PasswordHash == ComputeSha256Hash(dto.Password)).FirstOrDefaultAsync();

    return user == null ? AuthResponse.BadCredentials : AuthResponse.SuccessesLogin;
}
```
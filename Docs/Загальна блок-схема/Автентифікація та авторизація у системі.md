ToDo:
- [x] <mark style="background: #BBFABBA6;">Розгортання Redis ✅ 2024-03-06</mark>
- [x] <mark style="background: #BBFABBA6;">Розробка Telegram бота ✅ 2024-03-09</mark>
- [x] <mark style="background: #BBFABBA6;">Реалізація реакцію на команду /start ✅ 2024-03-09</mark>
- [x] <mark style="background: #BBFABBA6;">Написання методу отримання акаунтів користувача ✅ 2024-03-10</mark>
- [x] <mark style="background: #BBFABBA6;">Оновлення роботи команди /start ✅ 2024-03-10</mark>
- [x] <mark style="background: #BBFABBA6;">Написання сервісу для хешування даних в Redis ✅ 2024-03-11</mark>
- [x] <mark style="background: #BBFABBA6;">Написання машини станів ✅ 2024-03-11</mark>
- [x] <mark style="background: #BBFABBA6;">Реалізація команди входу в систему ✅ 2024-03-12</mark>
- [x] <mark style="background: #BBFABBA6;">Хешування даних про те, що користувач увійшов у систему ✅ 2024-03-12</mark>
- [x] <mark style="background: #BBFABBA6;">Реалізації команди реєстрації в системі ✅ 2024-03-12</mark>

## Розгортання Redis
Конфігурація Redis в docker-compose.yml:
```docker-compose
redis:
    image: redis:latest
    restart: always
    ports:
      - "6379:6379"
    volumes:
      - /path/to/local/data:/root/redis
      - /path/to/local/redis.conf:/usr/local/etc/redis/redis.conf
    environment:
      - REDIS_PORT=6379
```
## Розробка Telegram бота
Для розробки Telegram бота на мові програмування C# була використана бібліотека Telegram.Bot. Вона дозволяє створити сутність TelegramClient, який буде взаємодіяти із Telegram Bot Api.

Загальна діаграма роботи Telegram бота має наступний вигляд:
![[Pasted image 20240309174848.png]]

Але як обробляти повідомлення, що надходять від телеграму до нашого бота. З цим нам допомагає сама бібліотека, вона збирає всю інформацію про повідомлення, яке надходить до нашого телеграм бота. Також бібліотека має функціонал перевизначення методів обробки помилок та вхідних повідомлень.

Було вирішено застосувати патерн Фасад та створити обгортку для цього функціоналу. Діаграма класів для цього рішення має наступний вигляд: 
![[Pasted image 20240309203921.png]]

Як можна побачити на даній діаграмі, було створено інтерфейс ITelegramBotHandlers, в якому визначені методи необхідні для обробки вхідних повідомлень та помилок. Було створено клас TelegramBotHandlers, який наслідує інтерфейс ITelegramBotHandlers та реалізує його функціонал, також в ньому присутні декілька приватних методів, для легшої реалізації цього функціоналу. Для самого ж TelegramBotClient, який нам надає бібліотека Telegram.Bot, було створено дженерік клас-обгортку TelegramBot, в якому дженерік атрибутом є Handlers, який може бути сутністю будь-якого класу, який наслідує інтерфейс ITelegramBotHandlers.

Для запуску бота необхідно написати наступний код:
```CSharp
var bot = new TelegramBot<TelegramBotHandlers>();

bot.Init();
bot.StartReceiving();
```
## Реалізація реакцію на команду /start 
#### Команди
Як можна поміти, то в класі TelegramBotHandlers є два приватних поля \_messageCommands та \_callbackQueryCommands, які є списками команд, які реагують на команди із повідомлень та колбек запиту відповідно. Було створено загальний клас Command, в якому описані методи необхідні, як для роботи обох типів команд.
```CSharp
public abstract class Command
{
    public virtual List<string>? Names { get; set; }

    public virtual Task ExecuteAsync(ITelegramBotClient client, Message? message)
    {
        throw new NotImplementedException();
    }
    
    public virtual Task ExecuteAsync(ITelegramBotClient client, CallbackQuery? callbackQuery)
    {
        throw new NotImplementedException();
    }
    
    public virtual Task TryExecuteAsync(ITelegramBotClient client, Message? message)
    {
        throw new NotImplementedException();
    }

    public virtual Task TryExecuteAsync(ITelegramBotClient client, CallbackQuery? callbackQuery)
    {
        throw new NotImplementedException();
    }

    public virtual bool IsCanBeExecuted(string message)
    {
        foreach (var name in Names ?? [])
        {
            if (message.Contains(name))
            {
                return true;
            }
        }

        return false;
    }
}
```

На основі цього класу були реалізовані ще два абстрактні класи MessageCommand та CallbackQueryCommand, які реалізовували в собі функціонал для розпізнавання команд в повідомленнях та колбек запитах. Далі ці абстрактні клас будуть реалізовувати інші класи, які будуть відповідати за реалізацію певної команди. 
```CSharp
public class MessageCommand : Command
{
    public override async Task TryExecuteAsync(ITelegramBotClient client, Message? message)
    {
        if (IsCanBeExecuted(message?.Text ?? ""))
        {
            await ExecuteAsync(client, message);
        }
    }

    public override Task TryExecuteAsync(ITelegramBotClient client, CallbackQuery? callbackQuery)
    {
        Console.WriteLine("This is message command");

        return Task.CompletedTask;
    }
}
```

```CSharp
public class CallbackQueryCommand : Command
{
    public override Task TryExecuteAsync(ITelegramBotClient client, Message? message)
    {
        Console.WriteLine("This is callback query command");

        return Task.CompletedTask;
    }

    public override async Task TryExecuteAsync(ITelegramBotClient client, CallbackQuery? callbackQuery)
    {
        if (IsCanBeExecuted(callbackQuery?.Data ?? ""))
        {
            await ExecuteAsync(client, callbackQuery);
        }
    }
}
```
#### Команда /start
Команда /start наслідує абстрактний клас MessageCommand і має наступний вигляд:
```CSharp
public class StartCommand : MessageCommand
{
    public override List<string>? Names { get; set; } = [ "/start" ];

    public override async Task ExecuteAsync(ITelegramBotClient client, Message? message)
    {
        await client.SendTextMessageAsync(message!.Chat.Id, "Привіт! Я допоможу тобі взаємодіяти із твоїми віртуальними машинами", parseMode: ParseMode.Html);
    }
}
```

Приклад роботи:
![[Pasted image 20240309205006.png]]
## Написання методу отримання акаунтів користувача
Було розроблено метод, яка шукає користувачів за їх TelegramId. Він була реалізована для того, щоб при початку роботи із бот виводив користувачу повідомлення про те, що в нього вже є акаунти разом із юзернеймами акаунтів.

Метод в інтерфейсі, який буде відповідати за пошук акаунтів користувача:
```CSharp
Task<List<User>> GetUsersByTelegramIdAsync(long telegramId);
```

Його реалізації в сервісі:
```CSharp
public async Task<List<User>> GetUsersByTelegramIdAsync(long telegramId)
{
    return await CheckIfUserHasAccountAsync(telegramId) ? await _context.Users.Where(_ => _.TelegramId == telegramId).ToListAsync() : [];
}
```

Контролер:
```CSharp
[Route("api/[controller]")]
[ApiController]
public class AuthController : ControllerBase
{
    private readonly IAuthService _service;

    public AuthController(IAuthService service)
    {
        _service = service;
    }

    [HttpPost("login")]
    [ProducesResponseType(typeof(string), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<ActionResult<string>> LoginAsync(LoginDto dto)
    {
        return Ok((await _service.LoginAsync(dto)).ToString());
    }

    [HttpPost("register")]
    [ProducesResponseType(typeof(string), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<ActionResult<string>> RegisterAsync(RegisterDto dto)
    {
        return Ok((await _service.RegisterAsync(dto)).ToString());
    }

    [HttpGet("accounts/{telegramId}")]
    [ProducesResponseType(typeof(List<User>), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<ActionResult<List<User>>> GetUsersByTelegramIdAsync(long telegramId)
    {
        return Ok(await _service.GetUsersByTelegramIdAsync(telegramId));
    }
}
```
## Оновлення роботи команди /start
Для того, щоб отримати інформацію про акаунти користувача боту потрібно якось виконувати http запити до API користувача. Щоб легко та правильно виконувати ці запити було вирішено розробити клас обгортку RequestClient навколо стандартного класу C# - HttpClient.
```CSharp
public static class RequestClient
{
    private static HttpClient? _client;
    private static object _lock = new object();

    public static HttpClient? Client => GetInstance();

    private static HttpClient? GetInstance()
    {
        if (_client == null)
        {
            lock (_lock)
            {
                _client = new HttpClient();
                _client.BaseAddress = new Uri("https://localhost:8080");
            }
        }

        return _client;
    }
}
```

В RequestClient було реалізовано метод, який надсилати http запит на API сервер, обробляти його відповідь та повертати акаунти користувача:
```CSharp
public static async Task<List<User>?> GetUserAccountsAsync(long telegramId)
{
    var response = await Client!.GetAsync($"/api/Auth/accounts/{telegramId}");
    
    return JsonConvert.DeserializeObject<List<User>>(await response.Content.ReadAsStringAsync());
}
``` 

Також було створено клас-розширення для перетворення List of Users в текстовий список юзернеймів акаунтів, що належать користувачу.
```CSharp
public static class ListExtensions
{
    public static string ToStringList(this List<User> users)
    {
        var account = string.Join("\n", users.Select((user, index) => $"{index + 1}. {user.UserName}"));

        return account == string.Empty ? "У вас немає зареєстрованих акаунтів" : account;
    }
}
```

Оновлений обробник команди /start має наступний вигляд:
```CSharp
public class StartCommand : MessageCommand
{
    public override List<string>? Names { get; set; } = [ "/start" ];

    public override async Task ExecuteAsync(ITelegramBotClient client, Message? message)
    {
        var accounts = await RequestClient.GetUserAccountsAsync(message!.Chat.Id);

        await client.SendTextMessageAsync(message!.Chat.Id, $"Привіт! Я допоможу тобі взаємодіяти із твоїми віртуальними машинами\n\n{accounts?.ToStringList()}", 
            parseMode: ParseMode.Html);
    }
}
```

Приклад роботи:
![[Pasted image 20240310195230.png]]
## Написання сервісу для хешування даних в Redis
Для взаємодії з Redis через C# була використана бібліотека <mark style="background: #ADCCFFA6;">Microsoft.Extensions.Caching.StackExchangeRedis</mark>. Це високопродуктивний клієнт Redis, що включає як синхронне, так і асинхронне використання.

Для опису всіх необхідних методів було створено інтерфейс ICacheService:
```CSharp
public interface ICacheService
{
    Task SetValueAsync<T>(string key, T value, float expTimeInHours);
    Task GetValueAsync<T>(string key);
    Task DeleteDataAsync(string key);
}
```

Був розроблений клас CacheService, який реалізовує даний інтерфейс:
```CSharp
public class CacheService : ICacheService
{
    private readonly IDistributedCache _redis;

    public CacheService(IDistributedCache redis)
    {
        _redis = redis;
    }

    public async Task<T?> GetValueAsync<T>(string key)
    {
        var stringData = await _redis.GetStringAsync(key);

        return !string.IsNullOrEmpty(stringData) ? JsonConvert.DeserializeObject<T>(stringData) : default; 
    }

    public async Task SetValueAsync<T>(string key, T value, float expTimeInHours)
    {
        var stringData = JsonConvert.SerializeObject(value);
        var options = new DistributedCacheEntryOptions()
            .SetSlidingExpiration(TimeSpan.FromHours(expTimeInHours))
            .SetAbsoluteExpiration(DateTime.Now.AddHours(expTimeInHours));

        await _redis.SetStringAsync(key, stringData, options);
    }

    public async Task DeleteDataAsync(string key)
    {
        await _redis.RemoveAsync(key);
    }
}
```

Також були написані тести для, які сервіс хешування успішно пройшов.
## Написання машини станів
#### States
Для виконання деяких команд боту необхідно зберігати деякі попередньо введені дані. Як ось, наприклад, команда входу в систему. Боту спочатку потрібно запросити логін(юзернейм) користувача, "запам'ятати" його, а потім вже запитувати пароль, і після введення пароля користувачем вже робити спробувати входу в систему. Таких команд в системі може бути декілька, тому було вирішено створити універсальний клас State, в якому буде поле, яке буде зберігати назву стану, в якому перебуває користувач та об'єкт стану, якщо той необхідний.
```CSharp
public class State
{
    public string? StateName {  get; set; }
    public dynamic? StateObject { get; set; }
}
```

Було створено статичний клас, який реалізовує функціонал машини станів:
```CSharp
public static class StateMachine
{
    public static float ExpTimeInHours { get; set; } = 1f;

    public static async Task<State?> GetSateAsync(long telegramId)
    {
        var stateSting = await RequestClient.GetStateAsync(telegramId);

        return JsonConvert.DeserializeObject<State>(stateSting);
    }

    public static async Task SaveStateAsync(long telegramId, State state)
    {
        await RequestClient.SaveStateAsync(telegramId, state, ExpTimeInHours);
    }

    public static async Task RemoveStateAsync(long telegramId)
    {
        await RequestClient.RemoveStateAsync(telegramId);
    }
}
```

Для коректної роботи машини станів у клас RequestClient було додано два методи, які виконують запити до API кешування:
```CSharp
public static async Task<string> GetStateAsync(long telegramId)
{
    var response = await Client!.GetAsync($"https://localhost:8081/api/Cache/{telegramId}_state");

    return await response.Content.ReadAsStringAsync();
}

public static async Task SaveStateAsync(long telegramId, State state, float expTimeInHours)
{
    var stateSting = JsonConvert.SerializeObject(state);

    await Client!.PostAsync($"https://localhost:8081/api/Cache/{telegramId}_state?value={stateSting}&expTimeInHours={expTimeInHours}", null);
}

public static async Task RemoveStateAsync(long telegramId)
{
    await Client!.DeleteAsync($"https://localhost:8081/api/Cache/{telegramId}_state");
}
```
## Реалізація команди входу в систему
Команда AuthCommand, має декілька станів і розділяється на декілька блоків:
* Початок входу - створюється об'єкт стану, користувач входить в стан "input_username", його стан кешується
* Ввід імені акаунта - користувач вводить ім'я, яке зберігається в об'єкт стану, цей об'єкт знову кешується, а користувач переходить в стан "input_password"
* Ввід паролю - користувач вводить пароль і система виконує спробу входу
```CSharp
public class AuthCommand : MessageCommand
{
    private readonly ReplyKeyboardMarkup _keyboard = new([
        new KeyboardButton[] { "❌ Відмінити" }
    ])
    {
        ResizeKeyboard = true
    };

    public override List<string>? Names { get; set; } = [ "/auth", "Увійти в акаунт", "input_username", "input_password" ];

    public override async Task ExecuteAsync(ITelegramBotClient client, Message? message)
    {
        var userState = await StateMachine.GetSateAsync(message!.Chat.Id);
        
        if (message!.Text!.Contains('❌'))
        {
            await StateMachine.RemoveStateAsync(message!.Chat.Id);

            return;
        }

        if (userState == null)
        {
            userState = new State
            {
                StateName = "input_username",
                StateObject = new LoginDto()
            };

            await StateMachine.SaveStateAsync(message!.Chat.Id, userState);
            await client.SendTextMessageAsync(message!.Chat.Id, "Введіть ім'я користувача:", parseMode: ParseMode.Html, replyMarkup: _keyboard);
        }
        else if (userState?.StateName == "input_username")
        {
            userState.StateObject!.UserName = message?.Text;
            userState.StateName = "input_password";

            await StateMachine.SaveStateAsync(message!.Chat.Id, userState);
            await client.SendTextMessageAsync(message!.Chat.Id, "Введіть пароль:", parseMode: ParseMode.Html, replyMarkup: _keyboard);
        }
        else
        {
            userState!.StateObject!.Password = message?.Text;

            var response = await RequestClient.LoginAsync((userState.StateObject as JObject)!.ToObject<LoginDto>()!);

            if (response == AuthResponse.SuccessesLogin)
            {
                await client.SendTextMessageAsync(message!.Chat.Id, "Ви успішно увійшли до системи", parseMode: ParseMode.Html);
                await StateMachine.RemoveStateAsync(message!.Chat.Id);
            }
            else if (response == AuthResponse.BadCredentials)
            {
                userState.StateName = "input_username";

                await StateMachine.SaveStateAsync(message!.Chat.Id, userState);
                await client.SendTextMessageAsync(message!.Chat.Id, "Введіть ім'я користувача:", parseMode: ParseMode.Html, replyMarkup: _keyboard);
            }
        }
    }
}
```

Також у RequestClient був створений метод для входу:
```CSharp
public static async Task<AuthResponse> LoginAsync(LoginDto dto)
{
    var dtoString = JsonConvert.SerializeObject(dto);
    var content = new StringContent(dtoString, Encoding.UTF8, "application/json");
    var response = await Client!.PostAsync($"https://localhost:8080/api/Auth/login", content);

    return JsonConvert.DeserializeObject<AuthResponse>(await response.Content.ReadAsStringAsync());
}
```
## Хешування даних про те, що користувач увійшов у систему
У клас RequestClient було додано 2 методи, які допоможуть кешувати інформацію про те, що користувач увійти в систему. Перший метод виконує http запит на API для кешування даних в Redis, а другий перевіряє, чи є в Redis кешовані дані за заданим ключем.
```CSharp
public static async Task CacheAsync(string key, string value, float expTimeInHours)
{
    await Client!.PostAsync($"https://localhost:8081/api/Cache/{key}?value={value}&expTimeInHours={expTimeInHours}", null);
}

public static async Task<bool> CheckIfHasCacheAsync(string key)
{
    var response = await Client!.GetAsync($"https://localhost:8081/api/Cache/{key}");
    var data = JsonConvert.DeserializeObject(await response.Content.ReadAsStringAsync());

    return data != null;
}
```

Було створено сервіс, який відповідає за генерацію Jwt-токена, якщо вхід було проведено успішно. В даному токені буде зберігатися така інформація, як юзернейм акаунта, під яким увійшов користувач, а також ідентифікатор телеграму користувача:
```CSharp
public interface ITokenGenerateService
{
    string GenerateToken(LoginDto dto);
}
```

```CSharp
public class TokenGenerateService : ITokenGenerateService
{
    public string GenerateToken(LoginDto dto)
    {
        List<Claim> claims = [
            new Claim(ClaimTypes.Name, dto.UserName!),
            new Claim("telegram_id", $"{dto.TelegramId}")
        ];
        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes("This is my secret key"));
        var cred = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
        var tokenInfo = new JwtSecurityToken(claims: claims, expires: DateTime.UtcNow.AddDays(1), signingCredentials: cred);
        var token = new JwtSecurityTokenHandler().WriteToken(tokenInfo);

        return token;
    }
}
```

Також було змінено логіку ендпоїнту, який відповідає за вхід в систему:
```CSharp
[HttpPost("login")]
[ProducesResponseType(typeof(AuthResponse), StatusCodes.Status200OK)]
[ProducesResponseType(StatusCodes.Status500InternalServerError)]
public async Task<ActionResult<AuthResponse>> LoginAsync(LoginDto dto)
{
    var result = await _service.LoginAsync(dto);

    if (result == AuthResponse.SuccessesLogin)
    {
        var token = _tokenGenerateService.GenerateToken(dto);

        await _cacheService.SetValueAsync($"{dto.TelegramId}_auth", token, 1f);
    }

    return Ok(result);
}
```
## Реалізації команди реєстрації в системі
Команда має дуже схожий вигляд до команди входу, але ще додається стан вводу електронної пошти:
```CSharp
public class RegisterCommand : MessageCommand
{
    private readonly ReplyKeyboardMarkup _keyboard = new([
        new KeyboardButton[] { "❌ Відмінити" }
    ])
    {
        ResizeKeyboard = true
    };

    public override List<string>? Names { get; set; } = [ "/register", "Створити акаунт", "create_username", "create_password", "create_email" ];

    public override async Task ExecuteAsync(ITelegramBotClient client, Message? message)
    {
        var userState = await StateMachine.GetSateAsync(message!.Chat.Id);

        if (message!.Text!.Contains('❌'))
        {
            await StateMachine.RemoveStateAsync(message!.Chat.Id);

            return;
        }

        if (userState == null)
        {
            userState = new State
            {
                StateName = "create_username",
                StateObject = new RegisterDto()
            };

            await StateMachine.SaveStateAsync(message!.Chat.Id, userState);
            await client.SendTextMessageAsync(message!.Chat.Id, "Придумайте ім'я користувача:", parseMode: ParseMode.Html, replyMarkup: _keyboard);
        }
        else if (userState!.StateName == "create_username")
        {
            userState.StateObject!.UserName = message?.Text;
            userState.StateName = "create_password";

            await StateMachine.SaveStateAsync(message!.Chat.Id, userState);
            await client.SendTextMessageAsync(message!.Chat.Id, "Придумайте пароль:", parseMode: ParseMode.Html, replyMarkup: _keyboard);
        }
        else if (userState!.StateName == "create_password")
        {
            userState.StateObject!.Password = message?.Text;
            userState.StateName = "create_email";

            await StateMachine.SaveStateAsync(message!.Chat.Id, userState);
            await client.SendTextMessageAsync(message!.Chat.Id, "Введіть адрес електронної пошти:", parseMode: ParseMode.Html, replyMarkup: _keyboard);
        }
        else
        {
            userState.StateObject!.Email = message?.Text;
            userState.StateObject!.TelegramId = message?.Chat.Id;

            var response = await RequestClient.RegisterAsync((userState.StateObject as JObject)!.ToObject<RegisterDto>()!);

            if (response == AuthResponse.SuccessesRegister)
            {
                await client.SendTextMessageAsync(message!.Chat.Id, "Ви успішно зареєструвалися", parseMode: ParseMode.Html);
                await StateMachine.RemoveStateAsync(message!.Chat.Id);
            }
            else if (response == AuthResponse.AlreadyRegistered)
            {
                await client.SendTextMessageAsync(message!.Chat.Id, "Користувач з даним іменем вже зареєстрований", parseMode: ParseMode.Html);
                await StateMachine.RemoveStateAsync(message!.Chat.Id);
            }
        }
    }
}
```

Також у RequestClient був дописаний метод, який виконує http запит для реєстрації у системі:
```CSharp
public static async Task<AuthResponse> RegisterAsync(RegisterDto dto)
{
    var dtoString = JsonConvert.SerializeObject(dto);
    var content = new StringContent(dtoString, Encoding.UTF8, "application/json");
    var response = await Client!.PostAsync($"https://localhost:8080/api/Auth/register", content);

    return JsonConvert.DeserializeObject<AuthResponse>(await response.Content.ReadAsStringAsync());
}
```
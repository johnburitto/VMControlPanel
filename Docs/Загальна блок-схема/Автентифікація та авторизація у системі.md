ToDo:
- [x] <mark style="background: #BBFABBA6;">Розгортання Redis ✅ 2024-03-06</mark>
- [x] <mark style="background: #BBFABBA6;">Розробка Telegram бота ✅ 2024-03-09</mark>
- [x] <mark style="background: #BBFABBA6;">Реалізація реакцію на команду /start ✅ 2024-03-09</mark>
- [x] <mark style="background: #BBFABBA6;">Написання методу отримання акаунтів користувача ✅ 2024-03-10</mark>
- [ ] Оновлення роботи команди /start
- [ ] Реалізація команду входу в систему
- [ ] Написання сервісу для хешування даних в Redis
- [ ] Написання state машини
- [ ] Хешування даних про те, що користувач увійшов у систему

## Розгортання Redis
Конфігурація Redis в docker-compose.yml:
```docker-compose
redis:
    image: redis:latest
    restart: always
    ports:
      - "6379:6379"
    volumes:
      - /path/to/local/data:/root/redis
      - /path/to/local/redis.conf:/usr/local/etc/redis/redis.conf
    environment:
      - REDIS_PORT=6379
```
## Розробка Telegram бота
Для розробки Telegram бота на мові програмування C# була використана бібліотека Telegram.Bot. Вона дозволяє створити сутність TelegramClient, який буде взаємодіяти із Telegram Bot Api.

Загальна діаграма роботи Telegram бота має наступний вигляд:
![[Pasted image 20240309174848.png]]

Але як обробляти повідомлення, що надходять від телеграму до нашого бота. З цим нам допомагає сама бібліотека, вона збирає всю інформацію про повідомлення, яке надходить до нашого телеграм бота. Також бібліотека має функціонал перевизначення методів обробки помилок та вхідних повідомлень.

Було вирішено застосувати патерн Фасад та створити обгортку для цього функціоналу. Діаграма класів для цього рішення має наступний вигляд: 
![[Pasted image 20240309203921.png]]

Як можна побачити на даній діаграмі, було створено інтерфейс ITelegramBotHandlers, в якому визначені методи необхідні для обробки вхідних повідомлень та помилок. Було створено клас TelegramBotHandlers, який наслідує інтерфейс ITelegramBotHandlers та реалізує його функціонал, також в ньому присутні декілька приватних методів, для легшої реалізації цього функціоналу. Для самого ж TelegramBotClient, який нам надає бібліотека Telegram.Bot, було створено дженерік клас-обгортку TelegramBot, в якому дженерік атрибутом є Handlers, який може бути сутністю будь-якого класу, який наслідує інтерфейс ITelegramBotHandlers.

Для запуску бота необхідно написати наступний код:
```CSharp
var bot = new TelegramBot<TelegramBotHandlers>();

bot.Init();
bot.StartReceiving();
```
## Реалізація реакцію на команду /start 
#### Команди
Як можна поміти, то в класі TelegramBotHandlers є два приватних поля \_messageCommands та \_callbackQueryCommands, які є списками команд, які реагують на команди із повідомлень та колбек запиту відповідно. Було створено загальний клас Command, в якому описані методи необхідні, як для роботи обох типів команд.
```CSharp
public abstract class Command
{
    public virtual List<string>? Names { get; set; }

    public virtual Task ExecuteAsync(ITelegramBotClient client, Message? message)
    {
        throw new NotImplementedException();
    }
    
    public virtual Task ExecuteAsync(ITelegramBotClient client, CallbackQuery? callbackQuery)
    {
        throw new NotImplementedException();
    }
    
    public virtual Task TryExecuteAsync(ITelegramBotClient client, Message? message)
    {
        throw new NotImplementedException();
    }

    public virtual Task TryExecuteAsync(ITelegramBotClient client, CallbackQuery? callbackQuery)
    {
        throw new NotImplementedException();
    }

    public virtual bool IsCanBeExecuted(string message)
    {
        foreach (var name in Names ?? [])
        {
            if (message.Contains(name))
            {
                return true;
            }
        }

        return false;
    }
}
```

На основі цього класу були реалізовані ще два абстрактні класи MessageCommand та CallbackQueryCommand, які реалізовували в собі функціонал для розпізнавання команд в повідомленнях та колбек запитах. Далі ці абстрактні клас будуть реалізовувати інші класи, які будуть відповідати за реалізацію певної команди. 
```CSharp
public class MessageCommand : Command
{
    public override async Task TryExecuteAsync(ITelegramBotClient client, Message? message)
    {
        if (IsCanBeExecuted(message?.Text ?? ""))
        {
            await ExecuteAsync(client, message);
        }
    }

    public override Task TryExecuteAsync(ITelegramBotClient client, CallbackQuery? callbackQuery)
    {
        Console.WriteLine("This is message command");

        return Task.CompletedTask;
    }
}
```

```CSharp
public class CallbackQueryCommand : Command
{
    public override Task TryExecuteAsync(ITelegramBotClient client, Message? message)
    {
        Console.WriteLine("This is callback query command");

        return Task.CompletedTask;
    }

    public override async Task TryExecuteAsync(ITelegramBotClient client, CallbackQuery? callbackQuery)
    {
        if (IsCanBeExecuted(callbackQuery?.Data ?? ""))
        {
            await ExecuteAsync(client, callbackQuery);
        }
    }
}
```
#### Команда /start
Команда /start наслідує абстрактний клас MessageCommand і має наступний вигляд:
```CSharp
public class StartCommand : MessageCommand
{
    public override List<string>? Names { get; set; } = [ "/start" ];

    public override async Task ExecuteAsync(ITelegramBotClient client, Message? message)
    {
        await client.SendTextMessageAsync(message!.Chat.Id, "Привіт! Я допоможу тобі взаємодіяти із твоїми віртуальними машинами", parseMode: ParseMode.Html);
    }
}
```

Приклад роботи:
![[Pasted image 20240309205006.png]]
## Написання методу отримання акаунтів користувача
Було розроблено метод, яка шукає користувачів за їх TelegramId. Він була реалізована для того, щоб при початку роботи із бот виводив користувачу повідомлення про те, що в нього вже є акаунти разом із юзернеймами акаунтів.

Метод в інтерфейсі, який буде відповідати за пошук акаунтів користувача:
```CSharp
Task<List<User>> GetUsersByTelegramIdAsync(long telegramId);
```

Його реалізації в сервісі:
```CSharp
public async Task<List<User>> GetUsersByTelegramIdAsync(long telegramId)
{
    return await CheckIfUserHasAccountAsync(telegramId) ? await _context.Users.Where(_ => _.TelegramId == telegramId).ToListAsync() : [];
}
```

Контролер:
```CSharp
[Route("api/[controller]")]
[ApiController]
public class AuthController : ControllerBase
{
    private readonly IAuthService _service;

    public AuthController(IAuthService service)
    {
        _service = service;
    }

    [HttpPost("login")]
    [ProducesResponseType(typeof(string), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<ActionResult<string>> LoginAsync(LoginDto dto)
    {
        return Ok((await _service.LoginAsync(dto)).ToString());
    }

    [HttpPost("register")]
    [ProducesResponseType(typeof(string), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<ActionResult<string>> RegisterAsync(RegisterDto dto)
    {
        return Ok((await _service.RegisterAsync(dto)).ToString());
    }

    [HttpGet("accounts/{telegramId}")]
    [ProducesResponseType(typeof(List<User>), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<ActionResult<List<User>>> GetUsersByTelegramIdAsync(long telegramId)
    {
        return Ok(await _service.GetUsersByTelegramIdAsync(telegramId));
    }
}
```

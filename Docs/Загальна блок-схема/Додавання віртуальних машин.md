<mark style="background: #FFF3A3A6;">ToDo:</mark>
- [x] <mark style="background: #BBFABBA6;">Після входу вивести всі віртуальні машини, що додав користувач ✅ 2024-03-21</mark>
- [x] <mark style="background: #BBFABBA6;">Реалізувати команду додавання віртуальних машин ✅ 2024-03-21</mark>

## Після входу вивести всі віртуальні машини, що додав користувач
#### Додавання методу
Для цього нам потрібно створити метод, який буде витягувати із бази даних всі віртуальні машини, що належать користувачу, що увійшов у систему. Для цього в інтерфейс IVirtualMachineService було додано наступний метод:
```CSharp
Task<List<VirtualMachine>> GetUserVirtualMachines(string userId);
```

Його реалізація виглядає наступним чином:
```CSharp
public Task<List<VirtualMachine>> GetUserVirtualMachines(string userId)
{
    return _context.VirtualMachines.Where(_ => _.UserId ==  userId).ToListAsync();
}
```

Ендпоїнт:
```CSharp
[HttpGet("{userId}/all")]
[ProducesResponseType(typeof(List<VirtualMachine>), StatusCodes.Status200OK)]
[ProducesResponseType(StatusCodes.Status500InternalServerError)]
public async Task<ActionResult<VirtualMachine>> GetVirtualMachineByUserIdAndVMNameAsync(string userId)
{
    return Ok(await _service.GetUserVirtualMachines(userId));
}
```
#### Оновлення команди входу
Для хешування ідентифікатора користувача, під яким увійшли в систему в інтерфейс IAuthService було додано метод, який за даними, що були введені при успішному вході виконує пошук користувача, під яким увійшли:
```CSharp
Task<User?> GetUserByTelegramIdAndUserNameAsync(long telegramId, string? name);
```

Його реалізація:
```CSharp
public  Task<User?> GetUserByTelegramIdAndUserNameAsync(long telegramId, string? userName)
{
    return _context.Users.Where(_ => _.TelegramId == telegramId && _.UserName == userName).FirstOrDefaultAsync();
}
```

Ендпоїнт:
```CSharp
[HttpGet("{telegramId}/{userName}")]
[ProducesResponseType(typeof(User), StatusCodes.Status200OK)]
[ProducesResponseType(StatusCodes.Status204NoContent)]
[ProducesResponseType(StatusCodes.Status500InternalServerError)]
public async Task<ActionResult<User?>> GetUserByTelegramIdAndUserNameAsync(long telegramId, string userName)
{
    return Ok(await _service.GetUserByTelegramIdAndUserNameAsync(telegramId, userName));
}
```

В ендпоїнті, який відповідає за всіх була змінена логіка, яка виконується при успішному вході користувача в систему. Тепер відбувається не тільки кешування JWT токена користувача, а й кешується ідентифікатор акаунта, під яким користувач увійшов у систему:
```CSharp
if (result == AuthResponse.SuccessesLogin)
{
    var token = _tokenGenerateService.GenerateToken(dto);
    var user = await _service.GetUserByTelegramIdAndUserNameAsync(dto.TelegramId, dto.UserName);

    await _cacheService.SetValueAsync($"{dto.TelegramId}_auth", token, 1f);
    await _cacheService.SetValueAsync($"{dto.TelegramId}_current_user_id", $"{user?.Id}", 1f);
}
```

В клас RequestClient було додано метод, який буде витягувати захешований ідентифікатор користувача, а потім буде повертати із бази даних усі віртуальні машини, що належать даному користувачу:
```CSharp
public static async Task<List<VirtualMachine>> GetUserVirtualMachinesAsync(long telegramId)
{
    var response = await Client!.GetAsync($"https://localhost:8081/api/Cache/{telegramId}_current_user_id");
    var userId = await response.Content.ReadAsStringAsync();
    var virtualMachinesResponse = await Client!.GetAsync($"https://localhost:8081/api/VirtualMachine/{userId}/all");

    return JsonConvert.DeserializeObject<List<VirtualMachine>>(await virtualMachinesResponse.Content.ReadAsStringAsync()) ?? [];
}
```

Був написаний метод розширення, який перетворює список віртуальних машин у клавіатуру телеграм бота:
```CSharp
public static ReplyKeyboardMarkup ToKeyboard(this List<VirtualMachine> virtualMachines)
{
    var buttons = virtualMachines.Select((_, i) => new { _.Name, i })
                                 .GroupBy(_ => _.i / 3)
                                 .Select(_ => _.Select(_ => new KeyboardButton($"{_.Name}")))
                                 .ToList();

    buttons.Add([new KeyboardButton("➕ Додати нову машину")]);

    return new(buttons) { ResizeKeyboard = true };
}
```

Також оновлена логіка AuthCommand при успішному вході в систему:
```CSharp
if (response == AuthResponse.SuccessesLogin)
{
    var virtualMachines = await RequestClient.GetUserVirtualMachinesAsync(message!.Chat.Id);

    await client.SendTextMessageAsync(message!.Chat.Id, "Ви успішно увійшли до системи", parseMode: ParseMode.Html, replyMarkup: virtualMachines.ToKeyboard());
    await StateMachine.RemoveStateAsync(message!.Chat.Id);
}
```
## Реалізувати команду додавання віртуальних машин
В клас RequestClient було додано метод, який надсилає http запит на ендпоїнт створення віртуальної машини:
```CSharp
public static async Task<VirtualMachine?> AddVirtualMachineAsync(VirtualMachineDto dto)
{
    var dtoString = JsonConvert.SerializeObject(dto);
    var content = new StringContent(dtoString, Encoding.UTF8, "application/json");
    var response = await Client!.PostAsync($"https://localhost:8081/api/VirtualMachine", content);

    return JsonConvert.DeserializeObject<VirtualMachine>(await response.Content.ReadAsStringAsync());
}
```

Також була написана команда AddirtualMachineAsync, яка відповідає за збір необхідної інформації для додавання віртуальної машини:
```CSharp
public class AddVirtualMachineCommand : MessageCommand
{
    private readonly ReplyKeyboardMarkup _keyboard = new([
        new KeyboardButton[] { "❌ Відмінити" }
    ])
    {
        ResizeKeyboard = true
    };

    public override List<string>? Names { get; set; } = [ "➕ Додати нову машину", "input_vm_name", "input_vm_username", 
                                                          "input_vm_password", "input_vm_host", "input_vm_port" ];



    public override async Task ExecuteAsync(ITelegramBotClient client, Message? message)
    {
        var userState = await StateMachine.GetSateAsync(message!.Chat.Id);

        if (message!.Text!.Contains('❌'))
        {
            await StateMachine.RemoveStateAsync(message!.Chat.Id);

            return;
        }

        if (userState == null)
        {
            userState = new State
            {
                StateName = "input_vm_name",
                StateObject = new VirtualMachineDto()
            };

            await StateMachine.SaveStateAsync(message!.Chat.Id, userState);
            await client.SendTextMessageAsync(message!.Chat.Id, "Введіть ім'я віртуальної машини:", parseMode: ParseMode.Html, replyMarkup: _keyboard);
        }
        else if (userState?.StateName == "input_vm_name")
        {
            userState.StateObject!.Name = message.Text;
            userState.StateName = "input_vm_username";

            await StateMachine.SaveStateAsync(message!.Chat.Id, userState);
            await client.SendTextMessageAsync(message!.Chat.Id, "Введіть ім'я користувача на віртуальній машині:", parseMode: ParseMode.Html, replyMarkup: _keyboard);
        }
        else if (userState?.StateName == "input_vm_username")
        {
            userState.StateObject!.UserName = message.Text;
            userState.StateName = "input_vm_password";

            await StateMachine.SaveStateAsync(message!.Chat.Id, userState);
            await client.SendTextMessageAsync(message!.Chat.Id, "Введіть пароль користувача на віртуальній машині:", parseMode: ParseMode.Html, replyMarkup: _keyboard);
        }
        else if (userState?.StateName == "input_vm_password")
        {
            userState.StateObject!.Password = message.Text;
            userState.StateName = "input_vm_host";

            await StateMachine.SaveStateAsync(message!.Chat.Id, userState);
            await client.SendTextMessageAsync(message!.Chat.Id, "Введіть хоста віртуальної машини:", parseMode: ParseMode.Html, replyMarkup: _keyboard);
        }
        else if (userState?.StateName == "input_vm_host")
        {
            userState.StateObject!.Host = message.Text;
            userState.StateName = "input_vm_port";

            await StateMachine.SaveStateAsync(message!.Chat.Id, userState);
            await client.SendTextMessageAsync(message!.Chat.Id, "Введіть порт віртуальної машини:", parseMode: ParseMode.Html, replyMarkup: _keyboard);
        }
        else if (userState?.StateName == "input_vm_port")
        {
            try
            {
                userState.StateObject!.Port = int.Parse(message.Text);
                userState.StateObject!.UserId = await (await RequestClient.Client!.GetAsync($"https://localhost:8081/api/Cache/{message!.Chat.Id}_current_user_id"))
                    .Content.ReadAsStringAsync();

                var virtualMachine = await RequestClient.AddVirtualMachineAsync((userState.StateObject as JObject)!.ToObject<VirtualMachineDto>()!);
                var virtualMachines = await RequestClient.GetUserVirtualMachinesAsync(message!.Chat.Id);

                if (virtualMachine != null)
                {
                    await client.SendTextMessageAsync(message!.Chat.Id, "Віртуальна машина успішно додана", parseMode: ParseMode.Html, replyMarkup: virtualMachines.ToKeyboard()); 
                }
                else
                {
                    await client.SendTextMessageAsync(message!.Chat.Id, "Підчас додавання машини сталася помилка", parseMode: ParseMode.Html, replyMarkup: virtualMachines.ToKeyboard());
                }

                await RequestClient.RemoveStateAsync(message!.Chat.Id);
            }
            catch (Exception)
            {
                userState.StateName = "input_vm_port";

                await StateMachine.SaveStateAsync(message!.Chat.Id, userState);
            }
        }
    }
}
```

Працює вона схожим чином до команд AuthCommand та RegisterCommand, також працюючи із станами користувача
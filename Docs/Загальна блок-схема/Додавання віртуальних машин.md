<mark style="background: #FFF3A3A6;">ToDo:</mark>
- [x] <mark style="background: #BBFABBA6;">Після входу вивести всі віртуальні машини, що додав користувач ✅ 2024-03-21</mark>
- [ ] Реалізувати команду додавання віртуальних машин

## Після входу вивести всі віртуальні машини, що додав користувач
#### Додавання методу
Для цього нам потрібно створити метод, який буде витягувати із бази даних всі віртуальні машини, що належать користувачу, що увійшов у систему. Для цього в інтерфейс IVirtualMachineService було додано наступний метод:
```CSharp
Task<List<VirtualMachine>> GetUserVirtualMachines(string userId);
```

Його реалізація виглядає наступним чином:
```CSharp
public Task<List<VirtualMachine>> GetUserVirtualMachines(string userId)
{
    return _context.VirtualMachines.Where(_ => _.UserId ==  userId).ToListAsync();
}
```

Ендпоїнт:
```CSharp
[HttpGet("{userId}/all")]
[ProducesResponseType(typeof(List<VirtualMachine>), StatusCodes.Status200OK)]
[ProducesResponseType(StatusCodes.Status500InternalServerError)]
public async Task<ActionResult<VirtualMachine>> GetVirtualMachineByUserIdAndVMNameAsync(string userId)
{
    return Ok(await _service.GetUserVirtualMachines(userId));
}
```
#### Оновлення команди входу
Для хешування ідентифікатора користувача, під яким увійшли в систему в інтерфейс IAuthService було додано метод, який за даними, що були введені при успішному вході виконує пошук користувача, під яким увійшли:
```CSharp
Task<User?> GetUserByTelegramIdAndUserNameAsync(long telegramId, string? name);
```

Його реалізація:
```CSharp
public  Task<User?> GetUserByTelegramIdAndUserNameAsync(long telegramId, string? userName)
{
    return _context.Users.Where(_ => _.TelegramId == telegramId && _.UserName == userName).FirstOrDefaultAsync();
}
```

Ендпоїнт:
```CSharp
[HttpGet("{telegramId}/{userName}")]
[ProducesResponseType(typeof(User), StatusCodes.Status200OK)]
[ProducesResponseType(StatusCodes.Status204NoContent)]
[ProducesResponseType(StatusCodes.Status500InternalServerError)]
public async Task<ActionResult<User?>> GetUserByTelegramIdAndUserNameAsync(long telegramId, string userName)
{
    return Ok(await _service.GetUserByTelegramIdAndUserNameAsync(telegramId, userName));
}
```

В ендпоїнті, який відповідає за всіх була змінена логіка, яка виконується при успішному вході користувача в систему. Тепер відбувається не тільки кешування JWT токена користувача, а й кешується ідентифікатор акаунта, під яким користувач увійшов у систему:
```CSharp
if (result == AuthResponse.SuccessesLogin)
{
    var token = _tokenGenerateService.GenerateToken(dto);
    var user = await _service.GetUserByTelegramIdAndUserNameAsync(dto.TelegramId, dto.UserName);

    await _cacheService.SetValueAsync($"{dto.TelegramId}_auth", token, 1f);
    await _cacheService.SetValueAsync($"{dto.TelegramId}_current_user_id", $"{user?.Id}", 1f);
}
```

В клас RequestClient було додано метод, який буде витягувати захешований ідентифікатор користувача, а потім буде повертати із бази даних усі віртуальні машини, що належать даному користувачу:
```CSharp
public static async Task<List<VirtualMachine>> GetUserVirtualMachinesAsync(long telegramId)
{
    var response = await Client!.GetAsync($"https://localhost:8081/api/Cache/{telegramId}_current_user_id");
    var userId = await response.Content.ReadAsStringAsync();
    var virtualMachinesResponse = await Client!.GetAsync($"https://localhost:8081/api/VirtualMachine/{userId}/all");

    return JsonConvert.DeserializeObject<List<VirtualMachine>>(await virtualMachinesResponse.Content.ReadAsStringAsync()) ?? [];
}
```

Був написаний метод розширення, який перетворює список віртуальних машин у клавіатуру телеграм бота:
```CSharp
public static ReplyKeyboardMarkup ToKeyboard(this List<VirtualMachine> virtualMachines)
{
    var buttons = virtualMachines.Select((_, i) => new { _.Name, i })
                                 .GroupBy(_ => _.i / 3)
                                 .Select(_ => _.Select(_ => new KeyboardButton($"{_.Name}")))
                                 .ToList();

    buttons.Add([new KeyboardButton("➕ Додати нову машину")]);

    return new(buttons) { ResizeKeyboard = true };
}
```

Також оновлена логіка AuthCommand при успішному вході в систему:
```CSharp
if (response == AuthResponse.SuccessesLogin)
{
    var virtualMachines = await RequestClient.GetUserVirtualMachinesAsync(message!.Chat.Id);

    await client.SendTextMessageAsync(message!.Chat.Id, "Ви успішно увійшли до системи", parseMode: ParseMode.Html, replyMarkup: virtualMachines.ToKeyboard());
    await StateMachine.RemoveStateAsync(message!.Chat.Id);
}
```
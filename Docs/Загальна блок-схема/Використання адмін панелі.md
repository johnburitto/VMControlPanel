<mark style="background: #FFF3A3A6;">ToDo:</mark>
- [x] <mark style="background: #BBFABBA6;">Створити клас, який буде відповідати за шифрування/розшифрування даних ✅ 2024-03-19</mark>
- [x] <mark style="background: #BBFABBA6;">Створити клас, який буде описувати віртуальну машину користувача ✅ 2024-03-20</mark>
- [x] <mark style="background: #BBFABBA6;">Створити та прокинути міграції в базу даних ✅ 2024-03-20</mark>
- [x] <mark style="background: #BBFABBA6;">Створити сервіс для взаємодії із базою даних віртуальних машин ✅ 2024-03-20</mark>
- [x] <mark style="background: #BBFABBA6;">Написати контролер для методів сервісу ✅ 2024-03-20</mark>

## Створити клас, який буде відповідати за шифрування/розшифрування даних
Оскільки виконувати операції шифрування/розшифрування та хешування тепер необхідно виконувати не тільки в AuthService, а й в інших частинах коду, то вирішено всі методу необхідні для цього винести в окремий статичний клас CryptoService:
```CSharp
public static class CryptoService
{
    public static string BlowfishKey { get; set; } = "SomeSecretKey";

    public static string ComputeSha256Hash(string? data)
    {
        if (data == null)
        {
            return "";
        }

        var bytes = SHA256.HashData(Encoding.UTF8.GetBytes(data));
        var strBuilder = new StringBuilder();

        foreach (var _ in bytes)
        {
            strBuilder.Append(_.ToString("x2"));
        }

        return strBuilder.ToString();
    }

    public static string Blowfish(string? data, bool encrypt = true)
    {
        if (data == null)
        {
            return "";
        }

        var dataBytes = encrypt ? Encoding.UTF8.GetBytes(data) : Convert.FromBase64String(data);
        var cipher = new BufferedBlockCipher(new CbcBlockCipher(new BlowfishEngine()));

        while (dataBytes.Length % 8 != 0)
        {
            dataBytes = [..dataBytes, 0];
        }

        cipher.Init(encrypt, new KeyParameter(Encoding.UTF8.GetBytes(BlowfishKey)));

        var outputDataBytes = new byte[cipher.GetOutputSize(dataBytes.Length)];
        var length = cipher.ProcessBytes(dataBytes, 0, dataBytes.Length, outputDataBytes, 0);

        cipher.DoFinal(outputDataBytes, length);

        return encrypt ? Convert.ToBase64String(outputDataBytes) : Encoding.UTF8.GetString(outputDataBytes);
    }
}
```

Також в даний клас було додано метод Blowfish, який буде в майбутньому використовуватися для шифрування паролів для SSH підключення до віртуальної машини.
## Створити клас, який буде описувати віртуальну машину користувача
Було створено клас VirtualMachine, в якому описані поля, які будуть необхідні для підключення до віртуальної машини за допомогою SSH, а також поля, які характеризують належність до певного користувача:
```CSharp
public class VirtualMachine
{
    public int Id { get; set; }
    public string? Name { get; set; }
    public long UserTelegramId { get; set; }
    public string? Username { get; set; }
    public string? PasswordEncrypted { get; set; }
    public string? Password { get => CryptoService.Blowfish(PasswordEncrypted, false); set { } }
    public string? Host { get; set;}
    public int Port { get; set; }
}
```
## Створити та прокинути міграції в базу даних
Було створено клас AppDbContext. Це клас, який буде напряму взаємодіяти із базою даних та буде відповідати за всі інші сутності, які не увійшли в UserDbContext:
```CSharp
public class AppDbContext : DbContext
{
    public virtual DbSet<VirtualMachine> VirtualMachines { get; set; }

    public AppDbContext()
    {

    }

    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) 
    { 
    
    }
}
```

Для сутності VirtualMachine було створено файл конфігурації, в якому описано як і які саме поля із сутності зберігати в базу даних:
```CSharp
public class VirtualMachineConfiguration : IEntityTypeConfiguration<VirtualMachine>
{
    public void Configure(EntityTypeBuilder<VirtualMachine> builder)
    {
        builder.Property(_ => _.Id)
               .IsRequired()
               .UseIdentityColumn();

        builder.Property(_ => _.Name)
               .IsRequired();

        builder.Property(_ => _.UserTelegramId)
               .IsRequired();

        builder.Property(_ => _.Username)
               .IsRequired();

        builder.Property(_ => _.PasswordEncrypted)
               .IsRequired();

        builder.Property(_ => _.Host)
               .IsRequired();

        builder.Property(_ => _.Port)
               .IsRequired();
        
        builder.Ignore(_ => _.Password);
    }
}
```

Цю конфігурацію було застосовано:
```CSharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    base.OnModelCreating(modelBuilder);

    modelBuilder.ApplyConfiguration(new VirtualMachineConfiguration());
}
```

Для створення та прокидання потрібно встановити дві бібліотеки: Microsoft.EntityFrameworkCore.Design та Microsoft.EntityFrameworkCore.Tools

Команда для створення міграцій:
```
Add-Migration Init -o Data/Migrations
```

Файл міграції:
```CSharp
public partial class Init : Migration
{
    /// <inheritdoc />
    protected override void Up(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.CreateTable(
            name: "VirtualMachines",
            columns: table => new
            {
                Id = table.Column<int>(type: "int", nullable: false)
                    .Annotation("SqlServer:Identity", "1, 1"),
                Name = table.Column<string>(type: "nvarchar(max)", nullable: false),
                UserTelegramId = table.Column<long>(type: "bigint", nullable: false),
                Username = table.Column<string>(type: "nvarchar(max)", nullable: false),
                PasswordEncrypted = table.Column<string>(type: "nvarchar(max)", nullable: false),
                Host = table.Column<string>(type: "nvarchar(max)", nullable: false),
                Port = table.Column<int>(type: "int", nullable: false)
            },
            constraints: table =>
            {
                table.PrimaryKey("PK_VirtualMachines", x => x.Id);
            });
    }

    /// <inheritdoc />
    protected override void Down(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.DropTable(
            name: "VirtualMachines");
    }
}
```

Команда для прокидання міграції:
```
Update-Database
```
## Створити сервіс для взаємодії із базою даних віртуальних машин
Для опису всіх CRUD операцій, які можна виконати над сутністю було створено дженерік інтерфейс ICrudService, в якому у вигляді методів описані ці операції:
```CSharp
public interface ICrudService<T, TCreate, TUpdate>
{
    Task<List<T>> GetAllAsync();
    Task<T?> GetByIdAsync(int id);
    Task<T> CreateAsync(TCreate dto);
    Task<T> Update(TUpdate dto);
    Task DeleteAsync(T entity);
}
```

На основі даного інтерфейсу було створено інтерфейс IVirtualMachineService, який було доповнено необхідними методами:
```CSharp
public interface IVirtualMachineService : ICrudService<VirtualMachine, VirtualMachineDto, VirtualMachineDto>
{
    Task<VirtualMachine?> GetVirtualMachineByNameAndUserTelegramId(string name, long userTelegramId);
}
```

На основі інтерфейсу IVirtualMachineService було створено клас VirtualMachineService, який реалізовує цей інтерфейс:
```CSharp
public class VirtualMachineService : IVirtualMachineService
{
    private readonly AppDbContext _context;
    private readonly IMapper _mapper;

    public VirtualMachineService(AppDbContext context, IMapper mapper)
    {
        _context = context;
        _mapper = mapper;
    }

    public async Task<VirtualMachine> CreateAsync(VirtualMachineDto dto)
    {
        var expectedEntity = await GetVirtualMachineByUserTelegramIdAndNameAsync(dto.UserTelegramId, dto.Name);
    
        if (expectedEntity != null)
        {
            throw new Exception($"Virtual machine with name {dto.Name} already added");
        }

        var entity = _mapper.Map<VirtualMachine>(dto);

        await _context.VirtualMachines.AddAsync(entity);
        await _context.SaveChangesAsync();

        return entity;
    }

    public async Task DeleteAsync(VirtualMachine entity)
    {
        _context.VirtualMachines.Remove(entity);
        await _context.SaveChangesAsync();
    }

    public Task<List<VirtualMachine>> GetAllAsync()
    {
        return _context.VirtualMachines.ToListAsync();
    }

    public Task<VirtualMachine?> GetByIdAsync(int id)
    {
        return _context.VirtualMachines.Where(_ => _.Id == id).FirstOrDefaultAsync();
    }

    public Task<VirtualMachine?> GetVirtualMachineByUserTelegramIdAndNameAsync(long userTelegramId, string? name)
    {
        return _context.VirtualMachines.Where(_ => _.UserTelegramId == userTelegramId && _.Name == name).FirstOrDefaultAsync();
    }

    public async Task<VirtualMachine> Update(VirtualMachineDto dto)
    {
        var expectedEntity = await GetVirtualMachineByUserTelegramIdAndNameAsync(dto.UserTelegramId, dto.Name) ?? throw new Exception($"Virtual machine with name {dto.Name} doesn't exist");
        _mapper.Map(dto, expectedEntity);

        _context.VirtualMachines.Update(expectedEntity);
        await _context.SaveChangesAsync();

        return expectedEntity;
    }
}
```
##  Написати контролер для методів сервісу
#### Додавання аутомапера
<mark style="background: #ADCCFFA6;">AutoMapper</mark> — це об’єктно-об’єктний картограф. Відображення об’єкт-об’єкт працює шляхом перетворення вхідного об’єкта одного типу на вихідний об’єкт іншого типу. Що робить AutoMapper цікавим, так це те, що він надає деякі цікаві угоди, щоб позбавити від брудної роботи з’ясування того, як зіставити тип A з типом B. Поки тип B відповідає встановленим угодам AutoMapper, для зіставлення двох типів потрібна майже нульова конфігурація.

Ось конфігурація, яка було створена для класів VirtualMachine та VirtualMachineDto:
```CSharp
public class VirtualMachineProfile : Profile
{
    public VirtualMachineProfile() 
    {
        CreateMap<VirtualMachineDto, VirtualMachine>()
            .ForMember(dest => dest.PasswordEncrypted, options => options.MapFrom(src => CryptoService.Blowfish(src.Password, true)))
            .ForMember(dest => dest.Password, options => options.Ignore());
    }
}
```

Тут були додані додаткові правила для мапингу паролів. Саме ж підключення AutoMapper виглядає наступним чином:
```CSharp
builder.Services.AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies());
```
#### Написання контролера
```CSharp
[Route("api/[controller]")]
[ApiController]
public class VirtualMachineController : ControllerBase
{
    private readonly IVirtualMachineService _service;

    public VirtualMachineController(IVirtualMachineService service)
    {
        _service = service;
    }

    [HttpGet]
    [ProducesResponseType(typeof(List<VirtualMachine>), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<ActionResult<List<VirtualMachine>>> GetAllAsync()
    {
        return Ok(await _service.GetAllAsync());
    }

    [HttpGet("{id}", Name = "GetDiscountByIdAsync")]
    [ProducesResponseType(typeof(VirtualMachine), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<ActionResult<VirtualMachine?>> GetByIdAsync(int id)
    {
        var entity = await _service.GetByIdAsync(id);

        return entity != null ? Ok(entity) : NotFound();
    }

    [HttpGet("{userTelegramId}/{name}")]
    [ProducesResponseType(typeof(VirtualMachine), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<ActionResult<VirtualMachine?>> GetVirtualMachineByUserTelegramIdAndNameAsync(long userTelegramId, string name)
    {
        return Ok(await _service.GetVirtualMachineByUserTelegramIdAndNameAsync(userTelegramId, name));
    }

    [HttpPost]
    [ProducesResponseType(typeof(VirtualMachine), StatusCodes.Status201Created)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<ActionResult<VirtualMachine>> CreateAsync(VirtualMachineDto dto)
    {
        var entity = await _service.CreateAsync(dto);

        return CreatedAtRoute("GetDiscountByIdAsync", new { Id = entity.Id }, entity);
    }

    [HttpPut]
    [ProducesResponseType(typeof(VirtualMachine), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<ActionResult<VirtualMachine>> UpdateAsync(VirtualMachineDto dto)
    {
        return Ok(await _service.UpdateAsync(dto));
    }

    [HttpDelete("{id}")]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    [ProducesResponseType(StatusCodes.Status500InternalServerError)]
    public async Task<ActionResult> DeleteAsync(int id)
    {
        var entity = await _service.GetByIdAsync(id);

        if (entity == null)
        {
            return NotFound();
        }

        await _service.DeleteAsync(entity);

        return NoContent();
    }
}
```
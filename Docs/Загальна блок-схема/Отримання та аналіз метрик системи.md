<mark style="background: #FFF3A3A6;">ToDo:</mark>
- [x] <mark style="background: #BBFABBA6;">Написати скрипт, який буде збирати метрики ✅ 2024-04-12</mark>
- [x] <mark style="background: #BBFABBA6;">Написати метод, який буде отримувати дані від скрипту ✅ 2024-04-12</mark>
- [x] <mark style="background: #BBFABBA6;">Обробка та аналіз даних ✅ 2024-04-12</mark>
- [x] <mark style="background: #BBFABBA6;">Написати команду виводу даних користувачу ✅ 2024-04-12</mark>

## Написати скрипт, який буде збирати метрики
Мовою скрипту було обрано Python за його гнучкість та пристованость для таких речей як скриптинг. Тепер головним питанням залишається те, а де ж брати дані про стан віртуальної машини. В Linux існують такі команди як ``free``, ``top``, ``nproc`` та багато інших, які допомагають отримати певні дані про стан машини. Але мені необхідно зібрати всі ці дані в один об'єкт, щоб із ним було зручно працювати. При ретельному дослідженні було знайдено, що всі дані про стан машини Linux записує в файли, що знаходяться в директорії ``/proc/``, наприклад, у файлі ``/proc/stat`` зберігаються дані про стан процесора. Знайшовши шляхи до файлів, де зберігаються дані про необхідні метрики, а саме **стан процесора**, **стан носіїв даних**, **стан оперативної пам'яті** та **стан мережевих інтерфейсів**, я написав скрипти, які будуть отримувати ці дані.

Ось до прикладу метод, який отримує дані про навантаження процесора:
```Python
def cpu_percentage(sample_duration=1):
    deltas = cpu_times_deltas(sample_duration)

    total = sum(deltas)

    percents = [100 - (100 * (float(total - x)/ total)) for x in deltas]

    return cpu_dto.CpuPercentageDto(percents[0], percents[1], percents[2], percents[3], percents[4], percents[5], percents[6])
```

Всі отримані дані потрібно систематизувати та зібрати в об'єкт, який можна буде легко передавати. Для цього було використано принци Dto(Data Transfer Object), де для передані даних створюється клас, в якому будуть всі обхідні дані, і вже цей об'єкт буде передаватися. 

Ієрархія Dto об'єкта має наступний вигляд:
```Markdown
- MetricsDto (MetricsDto)
  - CpuDto (CpuMetricsDto)
    - Times (list)
    - CpuPercentage (CpuPercentageDto)
      - User (float)
      - Nice (float)
      - System (float)
      - Idle (float)
      - Iowait (float)
      - Irq (float)
      - Softirq (float)
    - ProcsNumber (dict)
    - FileDesc (list)
    - LoadAvg (list)
    - CpuInfo (dict)
  - DiscDto (DiskMetricsDto)
    - DiskBusy (dict)
    - DiskReadsWrites (dict)
    - DiskReadsWritesPersec (dict)
    - DiskUsage (dict)
  - MemDto (MemMetricsDto)
    - MemActive (float)
    - MemTotal (float)
    - MemCached (float)
    - MemFree (float)
    - SwapTotal (float)
    - SwapFree (float)
  - NetDto (NetMetricsDto)
    - RxTxBytes (dict)
    - RxTxBits (dict)
    - RxTxDump (dict)
    - NetStatsIfconfig (dict)
```

Збір даних мав наступний вигляд:
```Python
from metrics import cpu_metrics
from metrics import disk_metrics
from metrics import mem_metrics
from metrics import net_metrics
from dtos import metrics_dto

if __name__ == "__main__":
    dto = metrics_dto.MetricsDto()
    
    # cpu
    dto.CpuDto.Times = cpu_metrics.cpu_times()
    dto.CpuDto.CpuPercentage = cpu_metrics.cpu_percentage()
    dto.CpuDto.ProcsNumber['procs_running'] = cpu_metrics.procs_running()
    dto.CpuDto.ProcsNumber['procs_blocked'] = cpu_metrics.procs_blocked()
    dto.CpuDto.FileDesc = cpu_metrics.file_desc()
    dto.CpuDto.LoadAvg = cpu_metrics.load_avg()
    dto.CpuDto.CpuInfo = cpu_metrics.cpu_info()

    # disk
    for disc in disk_metrics.get_discs():
        dto.DiscDto.DiskBusy[disc] = disk_metrics.disk_busy(disc)
        dto.DiscDto.DiskReadsWrites[disc] = disk_metrics.disk_reads_writes(disc)
        dto.DiscDto.DiskReadsWritesPersec[disc] = disk_metrics.disk_reads_writes_persec(disc)
        #dto.disc_dto.disk_usage[disc] = disk_metrics.disk_usage(disc)

    # memory
    dto.MemDto = mem_metrics.mem_metrics()

    # network
    for interface in net_metrics.get_interfaces():
        dto.NetDto.RxTxBytes[interface] = net_metrics.rx_tx_bytes(interface)
        dto.NetDto.RxTxBits[interface] = net_metrics.rx_tx_bits(interface)
        dto.NetDto.RxTxDump[interface] = net_metrics.rt_xt_dump(interface)
        #dto.net_dto.net_stats_ifconfig[interface] = net_metrics.net_stats_ifconfig(interface)

    print(dto.to_dict())
```

Спочатку скрипт створює Dto-об'єкт, який буде заповнювати, далі збирає всі дані про центральний процесор, після чого отримує назви всіх носіїв даних, отримує дані про них, потім отримує дані про оперативну пам'ять машини, із мережевими інтерфейсами відбувається той самий алгоритм, що й із носіями даних. Вкінці скрипт виводить цей Dto-об'єкт у JSON представленні.

Цей скрипт завантажується на віртуальну машину, із якої потрібно отримати метрики. Також для легшого виконання даного скрипту був написаний ShellScript:
```Shell
#!/bin/sh
cd metrics-script
python3 main.py
```

## Написати метод, який буде отримувати дані від скрипту
Тепер на стороні клієнта потрібно, якось отримувати дані, що зібрав скрипт. Оскільки в нас є ShellScript, який запускає основний скрипт, Dto-об'єкт метрик виводиться до консолі та не потрібно вводити пароль або інші додаткові дані, то механізм отримання даних буде трішки іншим, аніж при виконанні команд через SSH. Для початку потрібно буде отримати/створити SSH-клієнт, який буде під'єднаний до віртуальної машини, але оскільки нам потрібно просто виконати команду та отримати відповідь, то не будемо створювати ShellStream, а скористаємося методом клієнта ``RunCommand(string command)``, результатом метод буде повертати відповідь машини у якій буде JSON представлення Dto-об'єкта метрик.

Опис методу в інтерфейсі ISSHRequestService:
```CSharp
Task<string> GetMetricsAsync(VirtualMachine virtualMachine, string userId);
```

Та його реалізація в SSHRequestService:
```CSharp
public async Task<string> GetMetricsAsync(VirtualMachine virtualMachine, string userId)
{
    var client = GetClient(virtualMachine, userId);

    if (!client.IsConnected)
    {
        await client.ConnectAsync(CancellationTokenSource.Token);
    }

    var response = client.RunCommand("./metrics.sh");

    return response.Result;
}
```

Також в контролер було додано ендпоїнт, виконуючи http-запит на який будемо отримувати метрики:
```CSharp
[HttpPost("metrics")]
[ProducesResponseType(typeof(string), StatusCodes.Status200OK)]
[ProducesResponseType(StatusCodes.Status500InternalServerError)]
public async Task<ActionResult<string>> GetMetricsAsync(SSHRequestDto dto)
{
    return Ok(await _service.GetMetricsAsync(dto.VirtualMachine!, dto.UserId!));
}
```

А в клас RequestClient було додано метод, який виконує http-запит на цей ендпоїнт:
```CSharp
public static async Task<MetricsDto?> GetMetircsAsync(SSHRequestDto dto)
{
    var dtoString = JsonConvert.SerializeObject(dto);
    var content = new StringContent(dtoString, Encoding.UTF8, "application/json");
    var response = await Client!.PostAsync($"https://localhost:8081/api/SSHRequest/metrics", content);

    return JsonConvert.DeserializeObject<MetricsDto>(await response.Content.ReadAsStringAsync());
}
```
## Обробка та аналіз даних
Для більш наочного подання даних користувачу було вирішено, якомога більше даних подати у вигляді графіків. Для побудови графіків було використано бібліотеку ScottPlot. <mark style="background: #ADCCFFA6;">ScottPlot</mark> — це безкоштовна бібліотека для побудови графіків із відкритим вихідним кодом для .NET, яка спрощує інтерактивне відображення великих наборів даних. Лінійні діаграми, стовпчасті діаграми, кругові діаграми, точкові діаграми тощо можна створити лише за допомогою кількох рядків коду. Дана бібліотека дозволяє будувати графіки всіх типів. Для унаочнення метрик були використані 3 наступні: графік-пиріг, графік-пончик та гістограма. 

Побудова графіка-пирога за допомогою засобів бібліотеки ScottPlot:
```CSharp
private static Plot CreatePieGraph(GraphDto dto)
{
    var plot = new Plot();
    var pies = new List<PieSlice>();
    var random = new Random();

    for (var i = 0; i < Math.Min(dto.Labels!.Count, dto.Values!.Count); i++)
    {
        pies.Add(new()
        {
            Value = dto.Values[i],
            FillColor = Color.FromARGB((uint)(random.NextDouble() * uint.MaxValue)),
            Label = $"{dto.Labels[i]} - {dto.Values[i]}"
        });
    }

    plot.Add.Pie(pies);
    plot.ShowLegend();
    plot.HideGrid();

    return plot;
}
```

Побудова графіка-пончика за допомогою засобів бібліотеки ScottPlot:
```CSharp
private static Plot CreateDonutGraph(GraphDto dto)
{
    var plot = new Plot();
    var pies = new List<PieSlice>();
    var random = new Random();

    for (var i = 0; i < Math.Min(dto.Labels!.Count, dto.Values!.Count); i++)
    {
        pies.Add(new()
        {
            Value = dto.Values[i],
            FillColor = Color.FromARGB((uint)(random.NextDouble() * uint.MaxValue)),
            Label = $"{dto.Labels[i]} - {dto.Values[i]}"
        });
    }

    plot.Add.Pie(pies).DonutFraction = 0.5;
    plot.ShowLegend();
    plot.HideGrid();

    return plot;
}
```

Побудова гістограми за допомогою засобів бібліотеки ScottPlot:
```CSharp
private static Plot CreateStackedBarPlot(GraphDto dto)
{
    var plot = new Plot();

    for (var i = 0; i < Math.Min(dto.Labels!.Count, dto.Values!.Count); i++)
    {
        plot.Add.Bars([i + 1], [dto.Values[i]]).Label = $"{dto.Labels[i]} - {dto.Values[i]}";
    }

    plot.Axes.Margins(bottom: 0);
    plot.ShowLegend(Alignment.UpperLeft);
    plot.HideGrid();

    return plot;
}
```

В усіх трьох випадках спочатку створюється полотно, на якому буде створюватися графік. Потім дані Dto-об'єкта GraphDto обробляються та наносяться на полотно у вигляді необхідних фігур, наприклад, "кусочків пирога" або стовпців гістограми. Після чого, якщо необхідно, то наноситься легенда та стирається розмітна сітка. Вкінці методи повертають полотно графіку.

В GraphDto знаходяться всі необхідні дані для побудови графіку, як назва, розміри, значення, підписи та інше:
```CSharp
public class GraphDto
{
    public string? Name { get; set; }
    public int Width { get; set; } = 1080;
    public int Height { get; set; } = 720;
    public List<string>? Labels { get; set; }
    public List<float>? Values { get; set; }
    public string? UserId { get; set; }
}
```

Після того, як методи побудували графік та повернули його, сервіс тимчасово зберігає його на диску та повертає шлях до об'єкта:
```CSharp
public static string CreateGraph(GraphType type, GraphDto dto)
{
    switch (type)
    {
        case GraphType.StackedBar:
            {
                var plot = CreateStackedBarPlot(dto);

                return SavedGraphToLocal(plot, dto);
            }
        case GraphType.Pie:
            {
                var plot = CreatePieGraph(dto);

                return SavedGraphToLocal(plot, dto);
            }
        case GraphType.Donut:
            {
                var plot = CreateDonutGraph(dto);

                return SavedGraphToLocal(plot, dto);
            }
        default: return string.Empty;
    }
}
```
## Написати команду виводу даних користувачу
Для виводу користувачу метрик системи було написано команду GetMetricsCommand. Яка може виводити метрики, як і в "сирому" вигляді, так і в формі графіків. Спочатку ця команда виконує http-запит на отримання даних про метрики віртуальної машини, далі перевіряє, чи у запиті користувача не було прапорців ``-r``, ``--raw``. Якщо вони були, то користувачу просто виводяться дані в "сирому" вигляді - у JSON представленні Dto-об'єкта метрик. Якщо ж цих прапорців не було, то команда будує графіки завантаженості процесора, кількості записів/читань кожного із носіїв даних, як за секунду, так і в загальному, зайнятості оперативної пам'яті та кількості відправлених та отриманих бітів даних кожного із інтерфейсів мережі. Далі користувачу надсилаються ці графіки, після чого вони видаляються із локального сховища.
```CSharp
public class GetMetricsCommand : MessageCommand
{
    public override List<string>? Names { get; set; } = [ "Метрики", "/metrics" ];

    public override async Task ExecuteAsync(ITelegramBotClient client, Message? message)
    {
        var userId = await (await RequestClient.Client!.GetAsync($"https://localhost:8081/api/Cache/{message?.Chat.Id}_current_user_id")).Content.ReadAsStringAsync();
        var dto = new SSHRequestDto
        {
            VirtualMachine = await RequestClient.GetCachedAsync<VirtualMachine>($"{message?.Chat.Id}_vm"),
            UserId = userId
        };
        var metrics = await RequestClient.GetMetircsAsync(dto);

        if (message!.Text!.Contains("-r") || message!.Text!.Contains("--raw"))
        {
            await client.SendTextMessageAsync(message!.Chat.Id, $"Raw data:```\n{JsonConvert.SerializeObject(metrics)}```", parseMode: ParseMode.MarkdownV2, replyMarkup: Keyboards.VMActionKeyboard);

            return;
        }

        var images = new List<string>();
        var cpuPercentage = new GraphDto
        {
            Name = "cpuPercentage",
            Labels = metrics!.CpuDto!.CpuPercentage!.GetType().GetProperties().Select(_ => _.Name).ToList(),
            Values = metrics!.CpuDto!.CpuPercentage!.GetType().GetProperties().Select(_ => float.Parse(_.GetValue(metrics!.CpuDto!.CpuPercentage)!.ToString() ?? "0.0")).ToList(),
            UserId = userId
        };
        var discBusy = new GraphDto
        {
            Name = "discBusy",
            Labels = metrics.DiscDto!.DiskBusy!.Select(_ => _.Key).ToList(),
            Values = metrics.DiscDto!.DiskBusy!.Select(_ => _.Value).ToList(),
            UserId = userId
        };
        var memory = new GraphDto
        {
            Name = "memory",
            Labels = metrics!.MemDto!.GetType().GetProperties().Select(_ => _.Name).ToList(),
            Values = metrics!.MemDto!.GetType().GetProperties().Select(_ => float.Parse(_.GetValue(metrics!.MemDto)!.ToString() ?? "0.0")).ToList(),
            UserId = userId
        };

        images.Add(GraphsService.CreateGraph(GraphType.Donut, cpuPercentage));
        images.Add(GraphsService.CreateGraph(GraphType.StackedBar, discBusy));
        images.Add(GraphsService.CreateGraph(GraphType.Pie, memory));
        
        foreach (var _ in metrics.DiscDto.DiskReadsWrites!)
        {
            var graphDto = new GraphDto
            {
                Name = $"DiskReadsWrites_{_.Key}",
                Labels = [ "reads", "writes" ],
                Values = _.Value.Select(_ => float.Parse(_.ToString())).ToList(),
                UserId = userId
            };

            images.Add(GraphsService.CreateGraph(GraphType.StackedBar, graphDto));
        }

        foreach (var _ in metrics.DiscDto.DiskReadsWritesPersec!)
        {
            var graphDto = new GraphDto
            {
                Name = $"DiskReadsWritesPersec_{_.Key}",
                Labels = ["reads", "writes"],
                Values = _.Value.Select(_ => float.Parse(_.ToString())).ToList(),
                UserId = userId
            };

            images.Add(GraphsService.CreateGraph(GraphType.StackedBar, graphDto));
        }

        foreach (var _ in metrics.NetDto!.RxTxBits!)
        {
            var graphDto = new GraphDto
            {
                Name = $"RxTxBits_{_.Key}",
                Labels = ["reads", "writes"],
                Values = _.Value.Select(_ => float.Parse(_.ToString())).ToList(),
                UserId = userId
            };

            images.Add(GraphsService.CreateGraph(GraphType.StackedBar, graphDto));
        }

        foreach (var _ in images)
        {
            using (var fileStream = FileManager.OpenFileAsStream(_))
            {
                await client.SendPhotoAsync(message.Chat.Id, InputFile.FromStream(fileStream), parseMode: ParseMode.Html, replyMarkup: Keyboards.VMActionKeyboard);
                //await client.SendTextMessageAsync(message.Chat.Id, $"{string.Join("\n", metrics.CpuDto.CpuInfo!.Select(_ => $"<b>{_.Key}:</b> {_.Value}"))}", 
                //    parseMode: ParseMode.Html, replyMarkup: Keyboards.VMActionKeyboard);
            }

            GraphsService.DeleteGraphFromLocal(_);
        }
    }
}
```